-- Seed Data: Cases 21-30

INSERT INTO cases (id, title, description, difficulty, category, starting_code, expected_output, suspects_json, evidence_json, xp_reward) VALUES 
(21, 'The Lambda Liar', 
 'A secret message needs to be sorted by length, not alphabetically. The killer used a lambda function to hide the sorting key. Sort the suspects list by name length.', 
 'Hard', 'Lambda', 
 'suspects = ["Christopher", "Ann", "Bo"]\n# Sort by length ascending\nsuspects.sort(key=lambda x: 0) # Fix the lambda\nprint(suspects)', 
 '[\'Bo\', \'Ann\', \'Christopher\']', 
 '[{"name": "Lam Bda", "bio": "Anonymous and quick."}, {"name": "Def Func", "bio": "Formal and verbose."}]',
 '["A scrambled list of names."]',
 600),

(22, 'The Map Murder', 
 'We found a list of prices ["$10", "$20"], but we need integers to trace the transaction. Use map() to strip the "$" and convert to int.', 
 'Hard', 'Map', 
 'prices = ["$10", "$20", "$30"]\n# Use map to clean it\nclean_prices = list(map(lambda x: x, prices)) # Fix the lambda\nprint(clean_prices)', 
 '[10, 20, 30]', 
 '[{"name": "Map Per", "bio": "One to one correspondence."}, {"name": "Red Ucer", "bio": "Boils it all down."}]',
 '["A receipt with dollar signs."]',
 600),

(23, 'The Generator Ghost', 
 'The killer set a bomb with a massive timer range (1 to 1,000,000). Creating a list of all numbers crashes the memory. Use a generator expression/yield to iterate safely without storing them.', 
 'Hard', 'Generators', 
 'def bomb_timer(n):\n    for i in range(n):\n        yield i\n\n# Create a generator, don''t print all\ngen = bomb_timer(3)\nprint(next(gen))\nprint(next(gen))', 
 '0\n1', 
 '[{"name": "Gen Erator", "bio": "Lazy but efficient."}, {"name": "Mem Ory", "bio": "Hoards everything."}]',
 '["A ticking server."]',
 700),

(24, 'The Regex Ripper', 
 'The killer hid his email in a text file full of junk. Extract the email using regex pattern matching. The email format is user@domain.com.', 
 'Hard', 'Regex', 
 'import re\ntext = "trash v@k.com more trash"\n# Find the email\nmatch = re.search(r"w+", text) # Fix the regex\nif match: print(match.group())', 
 'v@k.com', 
 '[{"name": "Reg Ex", "bio": "Matches perfectly."}, {"name": "Str Find", "bio": "Can only find simple things."}]',
 '["A messy text dump."]',
 700),

(25, 'The Classy Criminal', 
 'A Gun class has a bug. The shoot method doesn''t reduce ammo. Fix the method so `ammo` decreases by 1 each time.', 
 'Hard', 'Classes', 
 'class Gun:\n    def __init__(self):\n        self.ammo = 10\n    def shoot(self):\n        pass # Decrease ammo here\n\ng = Gun()\ng.shoot()\nprint(g.ammo)', 
 '9', 
 '[{"name": "Cla Ss", "bio": "High society."}, {"name": "Ob Ject", "bio": "Just an instance."}]',
 '["A gun that never runs out of ammo."]',
 800),

(26, 'The Inheritance Inheritance', 
 'The Detective class inherits from Person. But `super().__init__()` was forgotten, so the Detective has no name. Fix the inheritance.', 
 'Hard', 'Inheritance', 
 'class Person:\n    def __init__(self, name):\n        self.name = name\nclass Detective(Person):\n    def __init__(self, name):\n        # Call parent init\n        pass\n\nd = Detective("Sherlock")\nprint(d.name)', 
 'Sherlock', 
 '[{"name": "Par Ent", "bio": "Passed down his traits."}, {"name": "Chi Ld", "bio": "Inherited everything."}]',
 '["A family tree."]',
 800),

(27, 'The Decorator Death', 
 'Access to the crime scene requires a security badge. Use a decorator `@check_badge` to block access if `has_badge` is False.', 
 'Hard', 'Decorators', 
 'has_badge = True\ndef check_check(func):\n    # Implement decorator\n    return func\n\n@check_check\ndef enter_room():\n    print("Access Granted")\n\nenter_room()', 
 'Access Granted', 
 '[{"name": "Dec Orator", "bio": "Makes things look nice."}, {"name": "Wrap Per", "bio": "Hides the inner workings."}]',
 '["A police tape barrier."]',
 900),

(28, 'The Time Complexity Trap', 
 'The killer buried the evidence in a sorted list of 1 billion items. A linear search (for loop) detects it too slowly and times out. Use `bisect` (Binary Search) or equivalent logic to find it instantly.', 
 'Hard', 'Performance', 
 'import bisect\nevidence = [1, 3, 5, 7, 9]\n# Find index of 7 efficiently\nidx = bisect.bisect_left(evidence, 7)\nprint(idx)', 
 '3', 
 '[{"name": "Bi Nary", "bio": "Divides and conquers."}, {"name": "Lin Ear", "bio": "Takes one step at a time."}]',
 '["A massive pile of files."]',
 900),

(29, 'The Binary Body', 
 'The security system uses bitwise AND to check permissions. The required permission is 4 (binary 100). The user has 5 (101). Check if they have the permission.', 
 'Hard', 'Bitwise', 
 'user_perm = 5\nreq_perm = 4\n# Use bitwise AND (&)\nif (user_perm & req_perm):\n    print("Access")', 
 'Access', 
 '[{"name": "Bit Wise", "bio": "Operates on a low level."}, {"name": "Log Ical", "bio": "Thinks in True/False."}]',
 '["A circuit board."]',
 1000),

(30, 'The Algorithm Alibi', 
 'The final case. The killer is hiding in an unsorted list of DNA strings. Implementing a Quick Sort or Merge Sort is required to match the DNA to the database. (Mock: Just sort the list).', 
 'Hard', 'Algorithms', 
 'dna = ["G", "A", "C", "T"]\n# Sort it manually or using method\ndna.sort()\nprint(dna)', 
 '[\'A\', \'C\', \'G\', \'T\']', 
 '[{"name": "Al Gorithm", "bio": "Methodical killer."}, {"name": "Bub Ble", "bio": "Inefficient sorter."}]',
 '["A DNA sequence scan."]',
 1000);
